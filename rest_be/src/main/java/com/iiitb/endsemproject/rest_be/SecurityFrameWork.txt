Class Name,Package,Core Purpose,Analogy
OAuth2AuthenticationSuccessHandler,security,"The Bridge/JWT Issuer: It intercepts the successful login from Google, creates/updates the Faculty record in MySQL, generates your custom JWT, and redirects the user back to the React frontend with that token.","The Gate Agent who confirms your passport (OAuth) is good, registers you, and gives you your Boarding Pass (JWT)."
JwtAuthenticationFilter,security,"The Gatekeeper/Validator: It intercepts every protected API request (e.g., fetching salary data). It extracts the JWT from the header, validates its signature/expiration, and proves the user's identity to Spring Security.",The Airport Security Check. It only checks the validity of your Boarding Pass (JWT) before letting you proceed to the gate.
SecurityConfig,config,"The Rulebook/Coordinator: This central configuration class defines the entire security policy for the app. It enables CORS, disables CSRF, sets the session to STATELESS, defines which URLs are public, and crucially, tells Spring to use the OAuth2SuccessHandler and the JwtAuthenticationFilter.","The Airport Director. It sets the rules (e.g., ""All sessions must be stateless""), integrates the Gate Agent (Handler), and deploys Security Check (Filter) on all protected areas."
Faculty (Used in the Handler),entity,"The User Record: Stores the faculty member's basic data (email, name, picture URL, role) in the MySQL database.",The Registry. It's the central place where your application stores the faculty member's profile information.
FacultyRepository (Used in the Handler),repository,"The Data Access Tool: Provides simple methods (findByEmail, save) to interact with the Faculty table in the database.",The Librarian. It fetches or stores the user records from the Registry on command.

⚙️ How They Work Together in a Request
Login Request: The browser hits /oauth2/authorization/google.

Success Trigger: Google returns the code to the backend. Spring Security triggers the OAuth2AuthenticationSuccessHandler.

Handler Action: It uses the FacultyRepository to find/save the user, generates the JWT using JwtUtil, and redirects to React.

Protected Request: React sends a request (with the JWT) to /api/faculty/salary/history.

Filter Action: The JwtAuthenticationFilter intercepts the request, uses JwtUtil to validate the token, and sets the user as authenticated in Spring's memory.

Rule Check: The SecurityConfig rules allow the request to proceed to the controller because the filter successfully authenticated the user.

The reason the JwtAuthenticationFilter and the OAuth2AuthenticationSuccessHandler are automatically invoked is because the SecurityConfig explicitly registers them as part of the Spring Security Filter Chain, which is the core of how Spring handles web requests.

 How SecurityConfig Invokes the Custom Components1. Invoking the JWT Authentication FilterThe SecurityConfig tells Spring where to place your custom JwtAuthenticationFilter in the existing security workflow using the .addFilterBefore() method.Configuration LineWhat it DoesWhy it Works.addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)Manually inserts your jwtAuthFilter into the Spring Security pipeline.When a request hits your server, Spring Security processes a chain of built-in filters (around 15 of them). This command says: "Run my filter before Spring's default authentication filter (UsernamePasswordAuthenticationFilter.class) runs."Result:Since this filter is positioned near the front of the chain, it executes on every single request to check for a JWT.If the filter successfully validates the JWT, it sets the user as authenticated in the Security Context, and subsequent filters know the request is safe to proceed to your controller.2. Invoking the OAuth2 Authentication Success HandlerThe SecurityConfig tells the built-in Spring OAuth2 process to use your custom logic at the exact moment a successful login completes.Configuration LineWhat it DoesWhy it Works.oauth2Login(...)Enables the built-in OAuth2 Login process managed by Spring Security.Spring automatically creates the endpoints like /oauth2/authorization/google and handles the redirects to and from Google..successHandler(oauth2SuccessHandler)Registers your custom OAuth2AuthenticationSuccessHandler class.Spring Security has an internal mechanism for what to do after a successful login. This command overrides that default behavior, instructing Spring to call the onAuthenticationSuccess() method in your handler instead of its own.Result:Your custom handler runs, generates the JWT, and performs the final redirect to the React frontend.3. The Role of @Bean and @ComponentThese two annotations are crucial for making sure Spring finds and manages your custom classes:@Component / @Service (on the Handler and Filter): These annotations tell Spring's Inversion of Control (IoC) Container to create an instance (a "Bean") of these classes when the application starts up.Constructor Injection (in SecurityConfig):Javapublic SecurityConfig(OAuth2AuthenticationSuccessHandler oauth2SuccessHandler,
                      JwtAuthenticationFilter jwtAuthFilter) {
    this.oauth2SuccessHandler = oauth2SuccessHandler;
    this.jwtAuthFilter = jwtAuthFilter;
}
By defining these parameters in the SecurityConfig constructor, you tell Spring: "Before you create the SecurityConfig, please provide me with the instances of the OAuth2AuthenticationSuccessHandler and JwtAuthenticationFilter that you created via their @Component annotations."In summary, the SecurityConfig is the Director that uses dependency injection to obtain instances of the custom components, and then uses the Spring Security API (.addFilterBefore(), .successHandler()) to place those components at specific, powerful interception points within the security workflow.